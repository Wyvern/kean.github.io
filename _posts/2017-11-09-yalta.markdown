---
layout: post
title:  "Yalta: Micro Auto Layout DSL"
date:   2017-11-09 10:00:00 +0300
category: programming
tags: ios
permalink: /post/yalta
uuid: 00e90200-1ef8-479e-aea7-62b98a148c2e
---


[Yalta](https://github.com/kean/Yalta) is a new micro Auto Layout DSL which tries to achieve a perfect balance between power and simplicity.

If you'd like to learn about why it exists, who is it for, and why it might be the best tool for you, please continue. The best place to start using it is in a Playground [available in the project](https://github.com/kean/Yalta). It's going to feel instantly familiar!

<a href="{{ site.url }}/playgrounds/codable.playground.zip"><img src="{{ site.url }}/images/posts/yalta.png" class="screenshot"></a>


# Why

The primary motivation for releasing Yalta was [Chris Eidhof's article](http://chris.eidhof.nl/post/micro-autolayout-dsl/) in which he shares his concerns about the current state of Auto Layout tools in Swift. When I was deciding how to work with Auto Layout in my recent Swift project I came to the same conclusions as Chris did. Among the tools that I've investigated were:

- [PureLayout](https://github.com/PureLayout/PureLayout) which I used in my Objective-C projects before. It was a great library in Objective-C world, but even then it wasn't the one with the most concise syntax. In Swift it became even more apparent.
- [Carthography](https://github.com/PureLayout/PureLayout), [SnapKit](https://github.com/SnapKit/SnapKit) both have a unique API style foreign to Apple's APIs. And like Chris mentions in his article those are both extremely large and complex libraries, infested with operator overloads. Those tools have a very good chance of significantly [increasing your app's compile time](https://github.com/robb/Cartography/issues/215) which was a deal breaker for me.
- Apple's [NSLayoutAnchor](https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html) API was created in Objective-C world. I really like the idea behind anchors, but it's too verbose, requires manually activating each constraint, and there is no API for creating multiple constraints at once. I also dislike the fact that the API isn't very consistent, and that it puts too much emphasis on layout relations ("greater then", etc) which I rarely use in practice.
- A few other less popular third-party libraries. Some were really good, but they were not making the same compromises that I wanted to make.

So rather then pulling in a library I decided to write my own. The goal was to hit a balance between power and simplicity. I felt like I had a pretty good change of achieving that. After all, I already had plenty of experience working with Auto Layout. The first time we adopted it in our projects was back in iOS 6 days. More recently I made [Arranged](https://github.com/kean/Arranged) (UIStackView backport) and wrote about [UIStackView under the hood](https://kean.github.io/post/lets-build-uistackview). I had a good idea about what I would want from this tool. Now I decided to share it.


# Who Is This For

Yalta is for someone who:

- Wants clean, concise and convenient Auto Layout code which is consistent with modern Apple's APIs
- [Doesn't want](http://chris.eidhof.nl/post/micro-autolayout-dsl/) to depend on big, complex libraries, infected with custom operator overloads and protocols
- Prefers [fast compile times](https://github.com/robb/Cartography/issues/215)
- Likes [NSLayoutAnchor](https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html) but wished it had cleaner API, didn't requires manually activating each constraint, and allowed you to create multiple constraints at the same time

> [Yalta](https://en.wikipedia.org/wiki/Yalta) is a beautiful port city on the Black Sea, and a great name for *yet another layout tool* with *anchors*.


# ⛵️ Yalta

[Yalta](https://github.com/kean/Yalta) is an ultimate micro Auto Layout DSL - simple and powerful. It's a single file with under 250 lines of code. You can just copy it into your app and use it without having to manually import it in your files.


Yalta combines the idea of Apple's [layout anchors](https://developer.apple.com/documentation/uikit/nslayoutanchor) with expressive power of [PureLayout](https://github.com/PureLayout/PureLayout). It's instantly familiar. Yalta APIs are designed for clarity, consistency, and discoverability.


# Usage

Two most common operations when defining layouts are: creating and configuring **stack views**, and then **pinning** them to superviews. That's exactly what Yalta is optimized for:

```swift
let labels = Stack([title, subtitle], axis: .vertical)
let stack = Stack([image, labels], spacing: 15, alignment: .top)
stack.edges.pinToSuperviewMargins()
```

## Anchors

There is a single consistent way to use Yalta. First, you select either an *anchor* or a *collection of anchors*. Then you manipulate them using their methods. It requires less cognitive load then using long methods and helps with discoverability.

```swift
title.al.top.equal(subtitle.al.bottom) // Returns `NSLayoutConstraint`
title.al.height.equal(100)

// `UILayoutGuide` is supported:
title.al.leading.equal(view.al.margins.leading)
title.al.leading.equal(view.al.safeArea.leading)

// And you can create zero-overhead anchors with offsets on the fly:
let anchor = title.al.bottom.offset(by: 10)
subtitle.al.top.equal(anchor)

// If you need customization it's their for you:
title.al.top.equal(subtitle.al.bottom, offset: 10, relation: .greaterThanOrEqual)
title.al.height.equal(100, relation: .greaterThanOrEqual)
```

Anchors are similar to the native ones but with a few advantages:

- Activated automatically
- Designed for [Swift](https://swift.org/documentation/api-design-guidelines/), have a much smaller and discoverable API surface
- Less emphasis on relations which are rarely used in practice

## Anchors Collections

The most powerful Yalta's features come with *collections of anchors* which allow you to manipulate multiple attributes at the same time:

### Edges

```swift
// Pin all the edges at the same time:
title.al.edges.pinToSuperview()
title.al.edges.pinToSuperviewMargins()

// Or select which ones to pin:
title.al.edges(.leading, .trailing).pinToSuperview()

// `pin...` automatically figure out correct offsets and relations for you:
let insets = UIEdgeInsets(top: 10, left: 20, bottom: 10, right: 20)
title.al.edges.pinToSuperview(insets: insets, relation: .greaterThanOrEqual)

// If you are pinning not to superviews:
title.al.edges.pin(to: view.al)
title.al.edges.pin(to: view.al.margins)
title.al.edges.pin(to: view.al.safeArea)
```

### Axis

```swift
title.al.axis.centerInSuperview()
title.al.axis.centerInSuperviewMargins()
title.al.axis.equal(to: view.al.axis)
```

### Dimensions

```swift
title.al.size.equal(CGSize(width: 44, height: 44))
title.al.size.equal(CGSize(width: 44, height: 44), relation: .greaterThanOrEqual)

title.al.size.equal(subtitle.al.size)
title.al.size.equal(view.al.size, insets: CGSize(width: 20, height: 20))
title.al.size.equal(view.al.size, multiplier: 2)
```

## Stacks and Spacers

The second part of Yalta APIs focuses on manipulating stacks:

```swift
Stack([title, subtitle], axis: .vertical, spacing: 5)

Stack(title, subtitle) {
    $0.axis = .vertical
    $0.spacing = 5
}
```

And spacers:

```swift
Spacer(height: 16)
Spacer(minHeight: 16)
Stack(title, Spacer(width: 16), subtitle)
Stack(title, Spacer(minWidth: 16), subtitle)
```

## Priorities and Identifiers

Yalta autoinstalls created constraints. To lower the priority of the constraints use `Layout.make` method:

```swift
Layout.make(priority: UILayoutPriority(999), id: "PinToEdges") { // can be nested
    title.al.edges(.top, .leading, .trailing).pinToSuperview() // priority `999` and id "PinToEdges"
    title.al.bottom.pinToSuperview().identifier = "PinToBottom" // overrides "PinToEdges"
    title.al.width.equal(80).priority = UILayoutPriority(666) // overrides `999`
}
```
