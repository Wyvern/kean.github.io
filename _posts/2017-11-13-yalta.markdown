---
layout: post
title:  "Yalta: An Intuitive Auto Layout Library"
date:   2017-11-13 10:00:00 +0300
category: programming
tags: ios
permalink: /post/yalta
uuid: 00e90200-1ef8-479e-aea7-62b98a148c2e
---


[Yalta](https://github.com/kean/Yalta) is an intuitive and powerful Auto Layout library. Designed to be simple and safe, Yalta is perfect for both new and seasoned developers.

If you'd like to learn about *why it exists*, *who is it for*, and why it might be the best tool for you, please continue. The best place to start using it is in a Playground [available in the project](https://github.com/kean/Yalta). It's going to feel instantly familiar!


# Why

The primary motivation for releasing Yalta was [Chris Eidhof's article](http://chris.eidhof.nl/post/micro-autolayout-dsl/) in which he shares his concerns about the current state of Auto Layout tools in Swift. When I was deciding how to work with Auto Layout in my recent Swift project I came to the same conclusions as Chris did. Among the tools that I've investigated were:

- [PureLayout](https://github.com/PureLayout/PureLayout) which I used in my Objective-C projects before. It was a great library in Objective-C world, but even then it wasn't the one with the most concise syntax. In Swift it became even more apparent.
- [Cartography](https://github.com/robb/Cartography), [SnapKit](https://github.com/SnapKit/SnapKit). Both are pretty large and complex libraries. Operator overloads come with a good chance of [increasing the app's compile time](https://github.com/robb/Cartography/issues/215).
- Apple's [NSLayoutAnchor](https://developer.apple.com/library/ios/documentation/AppKit/Reference/NSLayoutAnchor_ClassReference/index.html) API was created in Objective-C era. I really like the idea behind anchors, but the actual API is verbose, requires manually activating each constraint, and there is no API for creating multiple constraints at once.

So rather then pulling in a library I decided to write my own. The goal was to hit a balance between power and simplicity. I felt like I had a pretty good chance of achieving that. After all, I already had plenty of experience working with Auto Layout. The first time we adopted it in our projects was back in iOS 6 days. More recently I made [Arranged](https://github.com/kean/Arranged) (UIStackView backport) and wrote about [UIStackView under the hood](https://kean.github.io/post/lets-build-uistackview). I had a good idea about what I wanted from this tool.


# â›µYalta

Yalta has quite a few advantages over other frameworks.

- Yalta strives for clarity and simplicity by following [Swift API Design Guidelines](https://swift.org/documentation/api-design-guidelines/). Although most of the APIs are compact, it is a *non-goal* to enable the most concise syntax possible.
- Yalta's APIs are fluent - methods form a grammatical phrases - that's what makes Swift and Objective-C stand out for me.
- It's extremely small and simple with just a single file with under 250 lines of code (compare with 1000 lines over 27 files in Cartography).
- There are no custom operators and thus no unexpected surprises like an [increasing in your app's compile time](https://github.com/robb/Cartography/issues/215).
- Yalta is designed to be approachable by new developers which benefits seasoned ones as well.

> [Yalta](https://en.wikipedia.org/wiki/Yalta) is a beautiful port city on the Black Sea, and a great name for *yet another layout tool* with *anchors*.


# Quick Overview

## Stack and Spacers

[`UIStackView`](https://developer.apple.com/documentation/uikit/uistackview) is king when it comes to aligning and distributing multiple views at the same time. Yalta doesn't try to compete with stacks - it complements them: 

```swift
// Creating stack views with Yalta require much less boilerplate:
let labels = Stack([title, subtitle], axis: .vertical)
let stack = Stack([image, labels], spacing: 15, alignment: .top)

// You also get a convenience of Spacers (including flexible ones):
Stack(title, Spacer(minWidth: 16), subtitle) // alt syntax
```

> Check out [Let's Build UIStackView](https://kean.github.io/post/lets-build-uistackview) to learn how stacks work under the hood (it's constraints all the way down).

## Fill and Center

It's time to add stack to a view hierarchy. Yalta has some high-level functions for that:

```swift
view.addSubview(stack)

// You may want your stack to fill the superview:
stack.al.fillSuperview()
stack.al.fillSuperview(insets: Insets(10)) // with insets
stack.al.fillSuperviewMargins() // or margins

// Or only fill along a particular axis and center along the other:
stack.al.fillSuperview(alongAxis: .horizontal)
stack.al.centerInSuperview(alongAxis: .vertical)
```

These are more **filling** and **centering** functions with more options available.


## Anchors

Stacks and `fill(...)` functions are great for laying out entire views, however sometime you have to think in terms of individual **anchors**. Each anchor represents either **edge**, **dimension** or **axis** of a view.

You can access anchors via `.al` extension however a recommended way is to create a `Constraints` group instead:

```swift
Constraints(for: title, subtitle) { title, subtitle in
    // Start with a `UIView` (or `UILayoutGuide`) and select one of the object's
    // anchors. Use anchor's methods to create constraints:
    title.top.pinToSuperview()

    // Yalta has a fluent API which read like grammatical phrase:
    subtitle.top.align(with: title.bottom, offset: 10)

    title.centerX.alignWithSuperview()
    subtitle.centerX.align(with: title.centerX)

    title.width.set(100)
    subtitle.width.match(title.width)

    // You can change a priority of constraints inside a group:
    subtitle.bottom.pinToSuperview().priority = UILayoutPriority(999)
}
```

> As you've probably noticed `Constraints` group allows you to get rid of `.al` prefix. More importantly, it encourages you to split constraints into small logical groups. Make sure that you do!

In some cases you might want to operate on multiple anchors at the same time:

```swift
Constraints(for: a, b) { a, b in
    a.center.align(with: b.center)
    a.size.match(b.size)
}
```
