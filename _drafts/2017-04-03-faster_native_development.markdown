---
layout: post
title:  "Native Development is Fast"
date:   2017-04-03 10:00:00 +0300
category: programming
tags: ios
permalink: /post/native-development-is-fast
uuid: 0d40647d-74cb-4ea1-97b4-3acfea271ba6
---

Native tools are not just powerful, but they also allow you to develop software really quickly. However, it does require a certain amount of discipline and practice to take a best advantage of the native tools.

> *by native tools I mean mostly Swift, Xcode, and UIKit

It's always great to rely on ubiquitous technologies. Those have a much better change that those won't break, are going to be supported in the future. Reduces risk. The ubiquitous tools tend to be the ones that the majority of the developers on the job market are going to be familiar with. It's easier to find support on the web.

Let's see what we can do with just native tools at our disposal.

# Introduction

The simplest development loop looks something like this. You make a change and then you need to:

1. build the project (incremental compilation makes this step really fast)
2. sign and install an app on the device (or simulator)
3. start an app and navigate to the screen that you are working on

This might take a lot of time depending on a number of factors. There are ways to speed this up. The main argument for using alternative tools (e.g. interpreted languages, code injection) is that they allow you to re-run the app faster thus making this loop faster. However let's take a step back and think about why do we need to go through this loop at all? We do this _to test our code for correctness_. We manually start an app and manually test a solution that we are working on. You might see where I'm going for this.

I think that testing your code manually should always be your last resort. It's tedious, it's _slow_, and it's error prone. Our goal shouldn't be to speed up this development loop but rather to get rid of it as much as we can. Aren't there any other ways of testing your code for correctness rather than manally re-running your app? Well, of course there are! It's a matter of taking advantage of those tools. I would argue that there are 3 main ways of testing your code for correctness which you can (and should) take advantage during native development:

## Swift Safety Features

Swift is a realy safe language. We have so many safety tools at our disposable (e.g. type safety, null safety, powerful abstraction mechanisms like algebraic data types). Static analyzes gives you instant feedback to let you know whether your code is correct. This is by far the fastest way to test your code for correctness (if happens as you type). It gives you a lot of confidence which allows you to increate the amount of code that you can safely write in a single sitting before ever running (or even compiling your app). This extra level of testing your app for correctess saves you a lot of time testing the app other ways (e.g. unit testing, actually running an app).

This first (and I would argue that it's actually the fastest) layer of testing your app for correctness is either completely missing in dynamic languages, or is can't really be compared to what Swift gives you.

## Layout

With an introduction of tools like `UIStackView` and Auto Layout Self-Sizing Cells the development of complex layouts on iOS become a breeze. So the techniques used in the web (e.g. Flexbox) no longer seem appealing. UIKit gives you a very powerful set of high to low level techniques which are seemlesly integrated. You can easily go from descriptive to imperative style.

## Thoughts on Interface Builder

Interface Builder is a controversial topic. I personally hate clicking buttons in the GUI. However some things are (arguably) more efficient in the GUI than in code.

There are two major parts of the work that you can get done using Interface Builder:

1. Layout
2. Style

I found that IB is great at defining the layout. Xcode became much smarter than it used to be when it comes to the Auto Layout. As long as you know all the tips and tricks which you can use, you can create and experiment with sets of constraints really quickly. And with Auto Layout the quick feedback loop is very important, because defining constrains is a messy process and its easy to screw up (given the constraint priorities, hugging and compression priorities, etc).

Defining the **layout** is great. You can iterate very quickly without ever running or even _compiling_ an app. It's arguably even faster than using DSLs on top of Auto Layout (e.g. Carthography, Pure Layout). I used to be a huge proponent of those tools but now I tend to rely less and less on them.

Defining the **style** is a different thing. In most cases you as a developer already all of the styles (e.g. colors, font sizes). For example, you might get those auto-generated by Zeplin. There is no need to experiment. It becomes really tedious to define the styles with in the IB GUI. You can't used predefined styles, you can't share styles throughout the app. You can no longer take advantage of the tools that auto-generate styles for you (e.g. Zeplin). The only pro is that in the IB you can visually see what you UI is going to look like without running an app. Fortunately, there is a way to achieve both (define styles programatically, and see them visually without ever running an app*. This involves two of my favorite IB features which are `@IBDesignable` and `prepareForInterfaceBuilder`.

*You still have to compile but with incremental compilation this isn't noticable.

- `prepareForInterfaceBuilder` + `@IBDesignable` to test the UI on a real data without ever running an app

## Testing

Throught the early years of my career I was always skeptical about testing. I thought that testing would slow me down, it would be a major pain to maintain test. Howover as time passed I started to realize how crucial tests really are, especially in our world of agile development when refactoring becomes a necessity when starting working on any of the task (user stories).

My most recent realization that made me completely fell in love with testing is that it allows me to develop features without ever running an app to test them. To be clear, I'm talking about unit tests here. At first it might seem that to test the UI you can only rely on some UI-driven testing (e.g. snapshot testing, Xcode UI testing, etc). However, you can use unit tests to test the UI as well. I actually really dislike any kind of UI-driven testing. Those are the tastes that constantly break, that are a major pain to maintain and in the end you end up not trusting those tests. I hate those kinds of tests. Those are the tests that the QA team should be responsible for (in case they are technically inclined to do so). We as developers have other responsibilities - testing the foundation of our code base (e.g. model layer). This is what we should test.

Tests should be super simple, stable, cheap to write and maintain. Basically you can't go wrong with unit tests. You can go wrong with other kinds of testing.

Test should always run on CI.

## Implementation

Let's start with creating our VC. We can use `UITableView` or `UICollectionView` or `UIStackView`. I'll stick with `UITableView` because its simple, ubiquitous.

You can start by creating a `ActivityView` which going to encapsulate a `UITableView` inside and used for live-rendering the entire table view inside the Storyboard. This is the first place where you can start testing (even TDD). You can create a method which creates `TableData` for a given `Activity` object (you can use [Sourcery](https://github.com/krzysztofzablocki/Sourcery) to generate this code for you) and write unit tests that directly implement the requirements (e.g. section _Rating_ is hidden when there were no ratings yet).

So we've just managed to develop and fully test the majority of our requirements without ever running an app.



From the design spec you can clearly see that you are going to need a bunch of different cells to render the UI. This might seem like something tedious, however most of the tedious work can be automated and that's exactly what I'm going to do. I'm going to use Ruby 2.0 and ERB in a very simple script to generate cell.swift and cell.xib files for all of those cells.

Now we need to wire those cells in a table view. This is also a thing that can be easily automated with a simple template.

I'll start with an initial project which already has model object which we are going to need (e.g. `Activity` class) as well as some helper methods and classes (e.g. `TableData` which represents a two-dimensional data structure designed specifically for table and collection views).

## Playgrounds

- Playgrounds https://github.com/kickstarter/ios-oss/tree/master/Kickstarter-iOS.playground/Pages

## Conclusion

We've managed to both improve the development cycle, but not with some hacks (e.g. code injection). We introduces some very structures and logical steps to improve the development flow that not only improve development speed, but also make it more predictable and reliable thanks to testings.

I think that using some clever ways (e.g. code injection, or just rewriting your non-compiled code on the fly) are on par with developing algorithms by mindlessly moving the things around and hoping that something would work. This is not hope I want to develop and deliver software.

You should also always keep in mind that you write code once, but you change it multiple times. So to be honest you shouldn't even be optimizing for how fast you are able to crank out the code, but rather for how easy it would be to maintain this code in the future, which is clearly something that native tools are better suited for.

# Drawbacks

- UIButton.setTitle doesn't work
- Managing bundles it pain in the ass
- Xcode is still piece of crap. Sometime @IBDesignable views just stop refreshing; Debugging those are a pain in the ass.
- When recompiling the project for rendering @IBDesignable inside the Storyboards indexing and code-completion hangs in the actual target.


# Improvements

It would be really great if Storyboards were as interactive as Playground are so that we could also use the IB to test our animations.



# Links

- Android Instant Run https://developer.android.com/studio/run/index.html#instant-run
- See about Playground here http://artsy.github.io/blog/2017/02/05/Retrospective-Swift-at-Artsy/

# Quotes

> Simplicity is prerequisite for reliability.
>   Edsger W. Dijkstra

> Simplicity — the art of maximizing the amount of work not done — is essential.
>   Principles behind the Agile Manifesto
